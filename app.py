# -*- coding: utf-8 -*-
"""WB_withoutfaiss.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZaMtRzzzp0vZzO2HwAxiZmTQop_YYwc0
"""

# --- Load Data and Models ---
import os, json, re, datetime, time
import numpy as np
import pickle
from sklearn.neighbors import NearestNeighbors
import streamlit as st
import google.generativeai as genai
from sentence_transformers import SentenceTransformer
import firebase_admin
from firebase_admin import credentials, firestore

# =========================
# Privacy & Config
# =========================
SIMILARITY_THRESHOLD = 0.80
DEBUG_MODE = True

# Configure Gemini API securely
gemini_api_key = st.secrets["GEMINI_API_KEY"]
genai.configure(api_key=gemini_api_key)

# =========================
# Firebase Setup
# =========================
if "firebase_initialized" not in st.session_state:
    firebase_key = json.loads(st.secrets["FIREBASE_KEY"])  # parse string → dict
    cred = credentials.Certificate(firebase_key)
    firebase_admin.initialize_app(cred)
    st.session_state.firebase_initialized = True
    st.success("✅ Connected to Firebase")

db = firestore.client()

# Load dataset
with open("text_data_merged_intents.json", "r") as f:
    data = json.load(f)

# Embedding model
embedding_model = SentenceTransformer("all-MiniLM-L6-v2")

# NearestNeighbors index
with open("my_index.pkl", "rb") as f:
    nn_index = pickle.load(f)   # scikit-learn NearestNeighbors

# Gemini model
gemini_model = genai.GenerativeModel('gemini-2.0-flash')

# =========================
# Privacy helpers
# =========================
PII_EMAIL = r'\b[\w.%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b'
PII_PHONE = r'(?:(?:\+?\d{1,3}[-.\s]?)?\(?\d{2,4}\)?[-.\s]?\d{3,4}[-.\s]?\d{3,4})'
PII_URL   = r'(?:https?://|www\.)\S+'
PII_NAME  = r'\b([A-Z][a-z]{2,})\b'

def redact_pii(text: str) -> str:
    if not text:
        return text
    text = re.sub(PII_URL, "<URL>", text)
    text = re.sub(PII_EMAIL, "<EMAIL>", text)
    text = re.sub(PII_PHONE, "<PHONE>", text)
    common_words = {"I","I'm","Im","Ive","My","The","And","But","So","Because"}
    def _maybe_name(m):
        w = m.group(1)
        return "<NAME>" if w not in common_words else w
    return re.sub(PII_NAME, _maybe_name, text)

# =========================
# Helpers
# =========================
def clean_text(text):
    text = text.lower()
    text = re.sub(r"http\S+|www\.\S+", "", text)
    text = re.sub(r"[^a-z\s<>_/:-]", "", text)
    text = re.sub(r"\s+", " ", text).strip()
    return text

def trim_response(text, max_words=120):
    words = text.split()
    return text if len(words) <= max_words else " ".join(words[:max_words]) + "..."

def save_session(chat_history, allow_logging=True):
    """Save chat session to Firebase Firestore"""
    if not allow_logging:
        return
    try:
        doc_ref = db.collection("chat_sessions").document()
        doc_ref.set({
            "history": chat_history,
            "timestamp": firestore.SERVER_TIMESTAMP
        })
        st.success("✅ Session saved to Firebase")
    except Exception as e:
        st.error(f"❌ Error saving session: {e}")


# --- Gamification (Improved) ---
def load_gamification(file_path="gamification.json"):
    if os.path.exists(file_path):
        with open(file_path, "r") as f:
            return json.load(f)
    return {
        "points": 0,
        "message_streak": 0,   # consecutive messages in current session
        "chat_start_time": None,
        "last_reward_time": None,
        "badges": [],
        "motivations": []
    }

def save_gamification(data, file_path="gamification.json"):
    with open(file_path, "w") as f:
        json.dump(data, f, indent=2)

def update_gamification(chat_history, gamedata, privacy_mode=False):
    now = datetime.datetime.now()

    # --- Track message streak ---
    gamedata["message_streak"] += 1
    gamedata["points"] += 5  # base points per message

    # --- Track chat duration (patience reward every 1 minute) ---
    if not gamedata["chat_start_time"]:
        gamedata["chat_start_time"] = now.isoformat()
        gamedata["last_reward_time"] = now.isoformat()
    else:
        start_time = datetime.datetime.fromisoformat(gamedata["chat_start_time"])
        last_reward_time = datetime.datetime.fromisoformat(gamedata["last_reward_time"])
        elapsed = (now - last_reward_time).total_seconds() / 60.0

        if elapsed >= 1:  # every 1 minute
            gamedata["points"] += 20
            gamedata["last_reward_time"] = now.isoformat()
            # Motivational dopamine feedback
            try:
                user_latest = chat_history[-1][1] if chat_history else ""
                motivation_prompt = f"""
                Generate one short, uplifting motivational message (under 20 words) 
                for a wellness chatbot user. 
                Base it on this latest user message: "{user_latest}" 
                and the fact they have stayed engaged for {int((now-start_time).total_seconds()/60)} minutes. 
                Do NOT mention 'minutes'. Keep it encouraging and empathetic.
                """
                motivation = get_gemini_response(motivation_prompt)
                gamedata["motivations"] = ["🌟 " + motivation.strip()]
            except:
                gamedata["motivations"] = ["💡 Keep going — you're doing amazing!"]

    # --- Always generate a motivation per message (replace each time) ---
    try:
        user_latest = chat_history[-1][1] if chat_history else ""
        motivation_prompt = f"""
        Write a short, positive reinforcement (max 15 words) for this user message: "{user_latest}".
        It should feel personal, encouraging, and empathetic.
        """
        motivation = get_gemini_response(motivation_prompt)
        gamedata["motivations"] = ["🌟 " + motivation.strip()]  # ✅ replaces instead of static text
    except:
        gamedata["motivations"] = ["💡 Keep going — you're doing amazing!"]

    # --- Badge system (recalculate each time) ---
    new_badges = []
    
    if gamedata["points"] == 5:
        new_badges.append("🌱 Beginner Step")
    
    if gamedata["points"] == 10:
        new_badges.append("💬 First Chat")
    
    if gamedata["points"] == 15:
        new_badges.append("🎯 Consistent Starter")
    
    if gamedata["points"] == 20:
        new_badges.append("🔥 Getting Momentum")
    
    if gamedata["points"] == 25:
        new_badges.append("⭐ Steady Achiever")
    
    if gamedata["points"] == 30:
        new_badges.append("🌟 Bright Mind")
    
    if gamedata["points"] == 35:
        new_badges.append("🚀 Uplifted Spirit")
    
    if gamedata["points"] == 40:
        new_badges.append("💎 Strong Commitment")
    
    if gamedata["points"] == 45:
        new_badges.append("🏆 Champion of Wellness")
    
    if gamedata["points"] == 50:
        new_badges.append("🌈 Master of Consistency")
    
    if gamedata["points"] >= 100:
        new_badges.append("100-points")
    
    if gamedata["points"] >= 200:
        new_badges.append("Motivation Master")
    
    gamedata["badges"] = new_badges  # ✅ overwrite instead of append

    # --- Motivational feedback via Gemini (strict safe mode) ---
    if len(gamedata["motivations"]) < 3 and gamedata["message_streak"] % 5 == 0:
        try:
            msg = get_gemini_response_strict(
                "Give me one short, uplifting sentence for someone who is making great progress in self-care and staying consistent.",
                chat_history
            )
            gamedata["motivations"] = ["💡 " + msg]
        except:
            gamedata["motivations"] = ["💡 Keep going — your consistency is inspiring!"]

    if not privacy_mode:
        save_gamification(gamedata)

    return gamedata



# --- Gemini API ---
def get_gemini_response(prompt, max_retries=3):
    for attempt in range(max_retries):
        try:
            response = gemini_model.generate_content(
                prompt,
                generation_config=genai.types.GenerationConfig(
                    max_output_tokens=200,
                    temperature=0.7,
                    top_p=0.9
                )
            )
            return response.text.strip()
        except Exception as e:
            if attempt == max_retries - 1:
                raise e
            print(f"Gemini API attempt {attempt + 1} failed, retrying...")
    return "I'm having trouble responding right now. Please try again."

# --- Gemini Main Response (Strict, no hallucinated names) ---
def get_gemini_response_strict(user_query, chat_history):
    history_snippets = "\n".join([f"- {msg}" for msg, _ in chat_history[-3:]])
    prompt = f"""
You are a supportive wellness assistant.
Rules:
- Never invent names, locations, or personal details unless the user explicitly provides them.
- Respond with empathy, kindness, and clarity.
- Focus only on the user's words and their feelings.

Recent conversation:
{history_snippets}

User query: {user_query}

Provide a natural, empathetic response.
"""
    return get_gemini_response(prompt).strip()

# --- Improved Intent Detection ---
def detect_intent_with_gemini(user_query, chat_history):
    history_snippets = "\n".join([f"- {msg}" for msg, _ in chat_history[-5:]])

    prompt = f"""
Analyze the following user message and classify it into ONE of these specific wellness intents:
- 'stress': When the user expresses anxiety, pressure, overwhelm, or tension
- 'anxiety': When the user mentions worry, nervousness, panic, or fear
- 'depression': When the user shows sadness, hopelessness, lack of energy, or low mood
- 'loneliness': When the user feels isolated, disconnected, or lacking social connection
- 'motivation': When the user struggles with productivity, goals, or finding purpose
- 'sleep': When the user mentions insomnia, tiredness, or sleep problems
- 'relationships': When the user discusses family, friends, or interpersonal issues
- 'self_care': When the user talks about taking care of themselves physically/mentally
- 'grief': When the user is dealing with loss or bereavement
- 'general': For general wellness questions or when no specific intent is clear

Conversation history:
{history_snippets}

Current message:
{user_query}

Return ONLY the single most appropriate intent keyword from the list above. Do not add any explanation.
"""

    intent = get_gemini_response(prompt)
    intent = intent.strip().lower()

    # Fallback to general if intent is not recognized
    valid_intents = {'stress', 'anxiety', 'depression', 'loneliness', 'motivation',
                    'sleep', 'relationships', 'self_care', 'grief', 'general'}

    return intent if intent in valid_intents else 'general'

# --- Intent-based Emoji Suggestions ---
def get_intent_based_emoji(intent):
    emoji_map = {
        'stress': '🌬️',
        'anxiety': '🧘',
        'depression': '☀️',
        'loneliness': '🤗',
        'motivation': '🚀',
        'sleep': '🌙',
        'relationships': '💞',
        'self_care': '💆',
        'grief': '🕯️',
        'general': '✨'
    }
    return emoji_map.get(intent, '✨')

# --- Dynamic Recommendation using Gemini (Strict) ---
def get_dynamic_recommendation(user_query, intent, chat_history):
    history_snippets = "\n".join([f"- {msg}" for msg, _ in chat_history[-3:]])

    # Get appropriate emoji based on intent
    intent_emoji = get_intent_based_emoji(intent)

    prompt = f"""
You are a wellness assistant.
Rules:
- Never invent names, locations, or personal details unless the user explicitly provides them.
- Suggest ONE short, practical, self-care action based on the user's feelings and the detected intent: {intent}
- Keep it under 25 words.
- Always begin with an emoji that matches the intent.

Recent conversation:
{history_snippets}

User query: {user_query}
Detected intent: {intent}

Output format: {intent_emoji} + short suggestion
"""
    suggestion = get_gemini_response(prompt).strip()

    # Ensure the suggestion starts with the intent-based emoji
    if not suggestion.startswith(intent_emoji):
        suggestion = f"{intent_emoji} {suggestion}"

    return suggestion if suggestion else "✨ Take a mindful pause for yourself."

# --- Core Response Logic (now privacy-aware) ---
def get_response(user_query, chat_history, privacy_mode=False, top_k=3, similarity_threshold=SIMILARITY_THRESHOLD):
    try:
        # Redact PII in Private Mode; keep original in Standard Mode
        query_for_processing = redact_pii(user_query) if privacy_mode else user_query

        # For NearestNeighbors, clean AFTER redaction so placeholders persist
        cleaned_query = clean_text(query_for_processing)
        query_embedding = embedding_model.encode([cleaned_query], convert_to_numpy=True)

        # Use scikit-learn NearestNeighbors
        distances, indices = nn_index.kneighbors(query_embedding, n_neighbors=top_k)

        matched = [data[i] for i in indices[0]]
        matched_queries = [x["query"] for x in matched]
        matched_answers = [x["answer"] for x in matched]
        cosine_similarity = 1 - distances[0][0]  # convert distance to similarity (approx)

        # Use redacted text for intent/LLM in Private Mode
        gemini_intent = detect_intent_with_gemini(query_for_processing, chat_history)

        if DEBUG_MODE:
            print("\n--- NearestNeighbors DEBUG ---")
            print(f"Privacy mode: {privacy_mode}")
            print(f"User input (raw): {user_query}")
            print(f"Processed (for model): {query_for_processing}")
            print(f"Top NearestNeighbors match: {matched_queries[0]}")
            print(f"Cosine similarity: {cosine_similarity:.4f}")
            print(f"Gemini Intent: {gemini_intent}")
            print("-------------------\n")

        if cosine_similarity >= similarity_threshold:
            faiss_answer = matched_answers[0]
            debug_meta = f"[📚 NearestNeighbors | Sim: {round(cosine_similarity, 2)} | Intent: {gemini_intent}]"
            final_response = f"{faiss_answer}\n{debug_meta}"
        else:
            response = get_gemini_response_strict(query_for_processing, chat_history)
            debug_meta = f"[🧠 LLM | Sim: {round(cosine_similarity, 2)} | Intent: {gemini_intent}]"
            final_response = trim_response(response) + "\n" + debug_meta

        # LLM-driven recommendation uses the same privacy-safe input
        recommendation_msg = get_dynamic_recommendation(query_for_processing, gemini_intent, chat_history)

         # --- Gamification ---
        gamedata = update_gamification(chat_history, st.session_state.gamedata, privacy_mode=privacy_mode)



        return f"{final_response}\n\n{recommendation_msg}", gamedata

    except Exception as e:
        print(f"Error in get_response: {str(e)}")
        return f"Sorry, error: {str(e)}", load_gamification()


# =========================
# Streamlit UI
# =========================
st.set_page_config(page_title="🌿 Wellness Companion", layout="wide")

# Custom CSS
st.markdown("""
<style>
    .chat-container {
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 10px;
        max-height: 500px;
        overflow-y: auto;
    }
    .user-message {
        background-color: #007ACC;  /* Strong blue */
        color: white;              /* White text */
        padding: 10px;
        border-radius: 10px;
        margin: 5px 0;
        text-align: right;         /* Align to right side */
    }
    .bot-message {
        background-color: #f0f0f0; /* Light grey */
        color: black;              /* Black text */
        padding: 10px;
        border-radius: 10px;
        margin: 5px 0;
        text-align: left;          /* Align to left side */
    }
</style>
""", unsafe_allow_html=True)


# Header
st.title("🌿 Wellness Companion")
st.caption("A safe space for mental health support and guidance")
st.warning("I am not a licensed therapist. If you're in crisis, please seek professional help.")

# Privacy settings
privacy_mode = st.radio("🔒 Privacy Mode:", ["Private", "Standard"], index=0, horizontal=True)
st.caption("🛡️ In Private mode, messages are anonymized (emails/phones/URLs/names redacted), history is not stored, and sessions are not logged.")

# Initialize session state
if "chat_history" not in st.session_state:
    st.session_state.chat_history = []

if "gamedata" not in st.session_state:
      # Ensure all required keys exist (fallbacks avoid KeyError)
      st.session_state.gamedata = {
        "points": 0,
        "message_streak": 0,
        "chat_start_time": None,
        "last_reward_time": None,
        "badges": [],
        "motivations": [],
        "last_points": 0,
    }


# Gamification sidebar
st.sidebar.header("🎮 Your Progress")
st.sidebar.write(f"🏅 Points: {st.session_state.gamedata['points']}")
st.sidebar.write(f"💬 Message Streak: {st.session_state.gamedata['message_streak']} messages")
st.sidebar.write(f"🎖️ Badges: {', '.join(st.session_state.gamedata['badges']) if st.session_state.gamedata['badges'] else 'None'}")

if st.session_state.gamedata.get("motivations"):
    st.sidebar.subheader("🌟 Motivations")
    for m in st.session_state.gamedata["motivations"][-3:]:
        st.sidebar.write(m)

# --- Dopamine Triggers (after gamification stats) ---

# 🎉 Confetti effect when hitting 100 points
if st.session_state.gamedata["points"] >= 100 and "100-points" not in st.session_state.gamedata["badges"]:
    st.balloons()
    st.session_state.gamedata["badges"].append("100-points")
    st.success("🏅 You just hit 100 points! Amazing progress!")

# 📊 Progress bar for next level (wraps every 100 points)
progress = min(st.session_state.gamedata["points"] % 100 / 100, 1.0)
st.progress(progress)

if progress == 1.0:
    st.success("🔥 Level Up! You reached the next milestone!")
    st.balloons()

# ⚡ Toasts for streaks / point milestones
if st.session_state.gamedata["message_streak"] > 5:
    st.toast("🔥 You're on fire! 5-message streak!", icon="🔥")

if st.session_state.gamedata["points"] % 50 == 0 and st.session_state.gamedata["points"] > 0:
    st.toast(f"🎉 You earned {st.session_state.gamedata['points']} points!", icon="🏆")

# 🌈 Fun animated text for instant reward
st.markdown(
    f"<h3 style='color:lime'>🎉 +{st.session_state.gamedata['points']} Points! Keep going 🚀</h3>",
    unsafe_allow_html=True
)


# Chat container
st.subheader("💬 Conversation")
chat_container = st.container()

# Display chat history
with chat_container:
    for role, msg in st.session_state.chat_history:
        if role == "You":
            st.markdown(f'<div class="user-message"><b>{role}:</b> {msg}</div>', unsafe_allow_html=True)
        else:
            st.markdown(f'<div class="bot-message"><b>{role}:</b> {msg}</div>', unsafe_allow_html=True)

# Input area
user_input = st.chat_input("How are you feeling today?")

if user_input:
    # Add user message to chat history
    display_message = redact_pii(user_input) if privacy_mode == "Private" else user_input
    st.session_state.chat_history.append(("You", display_message))

    # Get response
    with st.spinner("Thinking..."):
        response, gamedata = get_response(
            user_input,
            st.session_state.chat_history,
            privacy_mode=(privacy_mode == "Private")
        )

    # Add bot response to chat history
    st.session_state.chat_history.append(("Bot", response))
    st.session_state.gamedata = gamedata

    # Save session only in Standard Mode
    if privacy_mode == "Standard":
        save_session(st.session_state.chat_history, allow_logging=True)

    # Rerun to update the UI
    st.rerun()

# Clear chat button
if st.button("Clear Chat", type="secondary"):
    st.session_state.chat_history = []
    st.session_state.gamedata = {
        "points": 0,
        "message_streak": 0,
        "chat_start_time": None,
        "last_reward_time": None,
        "badges": [],
        "motivations": [],
        "last_points": 0,
    }
    st.rerun()
