# -*- coding: utf-8 -*-
"""WB_withoutfaiss.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZaMtRzzzp0vZzO2HwAxiZmTQop_YYwc0
"""

# --- Load Data and Models ---
import os, json, re, datetime, time
import numpy as np
import pickle
from sklearn.neighbors import NearestNeighbors
import streamlit as st
import google.generativeai as genai
from sentence_transformers import SentenceTransformer

# =========================
# Privacy & Config
# =========================
SIMILARITY_THRESHOLD = 0.60
DEBUG_MODE = True

# Configure Gemini API securely
gemini_api_key = st.secrets["GEMINI_API_KEY"]
genai.configure(api_key=gemini_api_key)

# Load dataset
with open("text_data_merged_intents.json", "r") as f:
    data = json.load(f)

# Embedding model
embedding_model = SentenceTransformer("all-MiniLM-L6-v2")

# NearestNeighbors index
with open("my_index.pkl", "rb") as f:
    nn_index = pickle.load(f)   # scikit-learn NearestNeighbors

# Gemini model
gemini_model = genai.GenerativeModel('gemini-2.0-flash')

# =========================
# Privacy helpers
# =========================
PII_EMAIL = r'\b[\w.%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b'
PII_PHONE = r'(?:(?:\+?\d{1,3}[-.\s]?)?\(?\d{2,4}\)?[-.\s]?\d{3,4}[-.\s]?\d{3,4})'
PII_URL   = r'(?:https?://|www\.)\S+'
PII_NAME  = r'\b([A-Z][a-z]{2,})\b'

def redact_pii(text: str) -> str:
    if not text:
        return text
    text = re.sub(PII_URL, "<URL>", text)
    text = re.sub(PII_EMAIL, "<EMAIL>", text)
    text = re.sub(PII_PHONE, "<PHONE>", text)
    common_words = {"I","I'm","Im","Ive","My","The","And","But","So","Because"}
    def _maybe_name(m):
        w = m.group(1)
        return "<NAME>" if w not in common_words else w
    return re.sub(PII_NAME, _maybe_name, text)

# =========================
# Helpers
# =========================
def clean_text(text):
    text = text.lower()
    text = re.sub(r"http\S+|www\.\S+", "", text)
    text = re.sub(r"[^a-z\s<>_/:-]", "", text)
    text = re.sub(r"\s+", " ", text).strip()
    return text

def trim_response(text, max_words=120):
    words = text.split()
    return text if len(words) <= max_words else " ".join(words[:max_words]) + "..."

def save_session(chat_history, file_path="chat_session_log.json", allow_logging=True):
    if not allow_logging: return
    try:
        if os.path.exists(file_path):
            with open(file_path, "r") as f: existing = json.load(f)
        else:
            existing = []
        existing.append(chat_history)
        with open(file_path, "w") as f: json.dump(existing, f, indent=2)
    except Exception as e: print(f"Error saving session: {e}")

# --- Gamification ---
def load_gamification(file_path="gamification.json"):
    if os.path.exists(file_path):
        with open(file_path, "r") as f: return json.load(f)
    return {"points": 0, "streak": 0, "last_active": None, "badges": []}

def save_gamification(data, file_path="gamification.json"):
    with open(file_path, "w") as f: json.dump(data, f, indent=2)

def update_gamification():
    gamedata = load_gamification()
    today = datetime.date.today().isoformat()
    gamedata["points"] += 10
    if gamedata["last_active"] != today:
        if gamedata["last_active"] == (datetime.date.today() - datetime.timedelta(days=1)).isoformat():
            gamedata["streak"] += 1
        else: gamedata["streak"] = 1
        gamedata["last_active"] = today
    if gamedata["points"] >= 50 and "Getting Started" not in gamedata["badges"]: gamedata["badges"].append("Getting Started")
    if gamedata["points"] >= 100 and "100 Club" not in gamedata["badges"]: gamedata["badges"].append("100 Club")
    if gamedata["streak"] >= 7 and "1-Week Streak" not in gamedata["badges"]: gamedata["badges"].append("1-Week Streak")
    save_gamification(gamedata)
    return gamedata

# --- Gemini API ---
def get_gemini_response(prompt, max_retries=3):
    for attempt in range(max_retries):
        try:
            response = gemini_model.generate_content(
                prompt,
                generation_config=genai.types.GenerationConfig(
                    max_output_tokens=200,
                    temperature=0.7,
                    top_p=0.9
                )
            )
            return response.text.strip()
        except Exception as e:
            if attempt == max_retries - 1:
                raise e
            print(f"Gemini API attempt {attempt + 1} failed, retrying...")
    return "I'm having trouble responding right now. Please try again."

# --- Gemini Main Response (Strict, no hallucinated names) ---
def get_gemini_response_strict(user_query, chat_history):
    history_snippets = "\n".join([f"- {msg}" for msg, _ in chat_history[-3:]])
    prompt = f"""
You are a supportive wellness assistant.
Rules:
- Never invent names, locations, or personal details unless the user explicitly provides them.
- Respond with empathy, kindness, and clarity.
- Focus only on the user's words and their feelings.

Recent conversation:
{history_snippets}

User query: {user_query}

Provide a natural, empathetic response.
"""
    return get_gemini_response(prompt).strip()

# --- Improved Intent Detection ---
def detect_intent_with_gemini(user_query, chat_history):
    history_snippets = "\n".join([f"- {msg}" for msg, _ in chat_history[-5:]])

    prompt = f"""
Analyze the following user message and classify it into ONE of these specific wellness intents:
- 'stress': When the user expresses anxiety, pressure, overwhelm, or tension
- 'anxiety': When the user mentions worry, nervousness, panic, or fear
- 'depression': When the user shows sadness, hopelessness, lack of energy, or low mood
- 'loneliness': When the user feels isolated, disconnected, or lacking social connection
- 'motivation': When the user struggles with productivity, goals, or finding purpose
- 'sleep': When the user mentions insomnia, tiredness, or sleep problems
- 'relationships': When the user discusses family, friends, or interpersonal issues
- 'self_care': When the user talks about taking care of themselves physically/mentally
- 'grief': When the user is dealing with loss or bereavement
- 'general': For general wellness questions or when no specific intent is clear

Conversation history:
{history_snippets}

Current message:
{user_query}

Return ONLY the single most appropriate intent keyword from the list above. Do not add any explanation.
"""

    intent = get_gemini_response(prompt)
    intent = intent.strip().lower()

    # Fallback to general if intent is not recognized
    valid_intents = {'stress', 'anxiety', 'depression', 'loneliness', 'motivation',
                    'sleep', 'relationships', 'self_care', 'grief', 'general'}

    return intent if intent in valid_intents else 'general'

# --- Intent-based Emoji Suggestions ---
def get_intent_based_emoji(intent):
    emoji_map = {
        'stress': 'ğŸŒ¬ï¸',
        'anxiety': 'ğŸ§˜',
        'depression': 'â˜€ï¸',
        'loneliness': 'ğŸ¤—',
        'motivation': 'ğŸš€',
        'sleep': 'ğŸŒ™',
        'relationships': 'ğŸ’',
        'self_care': 'ğŸ’†',
        'grief': 'ğŸ•¯ï¸',
        'general': 'âœ¨'
    }
    return emoji_map.get(intent, 'âœ¨')

# --- Dynamic Recommendation using Gemini (Strict) ---
def get_dynamic_recommendation(user_query, intent, chat_history):
    history_snippets = "\n".join([f"- {msg}" for msg, _ in chat_history[-3:]])

    # Get appropriate emoji based on intent
    intent_emoji = get_intent_based_emoji(intent)

    prompt = f"""
You are a wellness assistant.
Rules:
- Never invent names, locations, or personal details unless the user explicitly provides them.
- Suggest ONE short, practical, self-care action based on the user's feelings and the detected intent: {intent}
- Keep it under 25 words.
- Always begin with an emoji that matches the intent.

Recent conversation:
{history_snippets}

User query: {user_query}
Detected intent: {intent}

Output format: {intent_emoji} + short suggestion
"""
    suggestion = get_gemini_response(prompt).strip()

    # Ensure the suggestion starts with the intent-based emoji
    if not suggestion.startswith(intent_emoji):
        suggestion = f"{intent_emoji} {suggestion}"

    return suggestion if suggestion else "âœ¨ Take a mindful pause for yourself."

# --- Core Response Logic (now privacy-aware) ---
def get_response(user_query, chat_history, privacy_mode=False, top_k=3, similarity_threshold=SIMILARITY_THRESHOLD):
    try:
        # Redact PII in Private Mode; keep original in Standard Mode
        query_for_processing = redact_pii(user_query) if privacy_mode else user_query

        # For NearestNeighbors, clean AFTER redaction so placeholders persist
        cleaned_query = clean_text(query_for_processing)
        query_embedding = embedding_model.encode([cleaned_query], convert_to_numpy=True)

        # Use scikit-learn NearestNeighbors
        distances, indices = nn_index.kneighbors(query_embedding, n_neighbors=top_k)

        matched = [data[i] for i in indices[0]]
        matched_queries = [x["query"] for x in matched]
        matched_answers = [x["answer"] for x in matched]
        cosine_similarity = 1 - distances[0][0]  # convert distance to similarity (approx)

        # Use redacted text for intent/LLM in Private Mode
        gemini_intent = detect_intent_with_gemini(query_for_processing, chat_history)

        if DEBUG_MODE:
            print("\n--- NearestNeighbors DEBUG ---")
            print(f"Privacy mode: {privacy_mode}")
            print(f"User input (raw): {user_query}")
            print(f"Processed (for model): {query_for_processing}")
            print(f"Top NearestNeighbors match: {matched_queries[0]}")
            print(f"Cosine similarity: {cosine_similarity:.4f}")
            print(f"Gemini Intent: {gemini_intent}")
            print("-------------------\n")

        if cosine_similarity >= similarity_threshold:
            faiss_answer = matched_answers[0]
            debug_meta = f"[ğŸ“š NearestNeighbors | Sim: {round(cosine_similarity, 2)} | Intent: {gemini_intent}]"
            final_response = f"{faiss_answer}\n{debug_meta}"
        else:
            response = get_gemini_response_strict(query_for_processing, chat_history)
            debug_meta = f"[ğŸ§  LLM | Sim: {round(cosine_similarity, 2)} | Intent: {gemini_intent}]"
            final_response = trim_response(response) + "\n" + debug_meta

        # LLM-driven recommendation uses the same privacy-safe input
        recommendation_msg = get_dynamic_recommendation(query_for_processing, gemini_intent, chat_history)

        # In Private Mode, skip gamification persistence (no identifiable trail)
        if privacy_mode:
            gamedata = {"points": 0, "streak": 0, "last_active": None, "badges": []}
        else:
            gamedata = update_gamification()

        return f"{final_response}\n\n{recommendation_msg}", gamedata

    except Exception as e:
        print(f"Error in get_response: {str(e)}")
        return f"Sorry, error: {str(e)}", load_gamification()

# =========================
# Streamlit UI
# =========================
st.set_page_config(page_title="ğŸŒ¿ Wellness Companion", layout="wide")

# Custom CSS
st.markdown("""
<style>
    .chat-container {
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 10px;
        max-height: 500px;
        overflow-y: auto;
    }
    .user-message {
        background-color: #e6f7ff;
        padding: 10px;
        border-radius: 10px;
        margin: 5px 0;
    }
    .bot-message {
        background-color: #f9f9f9;
        padding: 10px;
        border-radius: 10px;
        margin: 5px 0;
    }
</style>
""", unsafe_allow_html=True)

# Header
st.title("ğŸŒ¿ Wellness Companion")
st.caption("A safe space for mental health support and guidance")
st.warning("I am not a licensed therapist. If you're in crisis, please seek professional help.")

# Privacy settings
privacy_mode = st.radio("ğŸ”’ Privacy Mode:", ["Private", "Standard"], index=0, horizontal=True)
st.caption("ğŸ›¡ï¸ In Private mode, messages are anonymized (emails/phones/URLs/names redacted), history is not stored, and sessions are not logged.")

# Initialize session state
if "chat_history" not in st.session_state:
    st.session_state.chat_history = []
if "gamedata" not in st.session_state:
    st.session_state.gamedata = load_gamification()

# Gamification sidebar
st.sidebar.header("ğŸ® Your Progress")
st.sidebar.write(f"ğŸ… Points: {st.session_state.gamedata['points']}")
st.sidebar.write(f"ğŸ”¥ Streak: {st.session_state.gamedata['streak']} days")
st.sidebar.write(f"ğŸ–ï¸ Badges: {', '.join(st.session_state.gamedata['badges']) if st.session_state.gamedata['badges'] else 'None'}")

# Chat container
st.subheader("ğŸ’¬ Conversation")
chat_container = st.container()

# Display chat history
with chat_container:
    for role, msg in st.session_state.chat_history:
        if role == "You":
            st.markdown(f'<div class="user-message"><b>{Role}:</b> {msg}</div>', unsafe_allow_html=True)
        else:
            st.markdown(f'<div class="bot-message"><b>{Role}:</b> {msg}</div>', unsafe_allow_html=True)

# Input area
user_input = st.chat_input("How are you feeling today?")

if user_input:
    # Add user message to chat history
    display_message = redact_pii(user_input) if privacy_mode == "Private" else user_input
    st.session_state.chat_history.append(("You", display_message))

    # Get response
    with st.spinner("Thinking..."):
        response, gamedata = get_response(
            user_input,
            st.session_state.chat_history,
            privacy_mode=(privacy_mode == "Private")
        )

    # Add bot response to chat history
    st.session_state.chat_history.append(("Bot", response))
    st.session_state.gamedata = gamedata

    # Save session only in Standard Mode
    if privacy_mode == "Standard":
        save_session(st.session_state.chat_history, allow_logging=True)

    # Rerun to update the UI
    st.rerun()

# Clear chat button
if st.button("Clear Chat", type="secondary"):
    st.session_state.chat_history = []
    st.rerun()